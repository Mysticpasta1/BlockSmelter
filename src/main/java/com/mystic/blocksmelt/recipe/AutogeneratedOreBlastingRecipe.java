package com.mystic.blocksmelt.recipe;

import com.google.gson.JsonObject;
import com.mystic.blocksmelt.Blocksmelt;
import dev.lukebemish.excavatedvariants.impl.ModifiedOreBlock;
import net.minecraft.core.RegistryAccess;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.Container;
import net.minecraft.world.SimpleContainer;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import net.minecraft.world.item.crafting.BlastingRecipe;
import net.minecraft.world.item.crafting.CookingBookCategory;
import net.minecraft.world.item.crafting.Ingredient;
import net.minecraft.world.item.crafting.RecipeManager;
import net.minecraft.world.item.crafting.RecipeSerializer;
import net.minecraft.world.item.crafting.RecipeType;
import net.minecraft.world.item.crafting.SmeltingRecipe;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.Block;
import net.minecraftforge.registries.ForgeRegistries;
import org.jetbrains.annotations.Nullable;

import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

public class AutogeneratedOreBlastingRecipe extends BlastingRecipe {
    private final Map<Item, ItemStack> cachedResults = new IdentityHashMap<>();
    private @Nullable RecipeManager cachedRecipeManager;

    public AutogeneratedOreBlastingRecipe(ResourceLocation id) {
        super(
                id,
                "",
                CookingBookCategory.MISC,
                Ingredient.EMPTY,
                ItemStack.EMPTY,
                0.0F,
                100
        );
    }

    @Override
    public boolean matches(Container container, Level level) {
        ItemStack input = container.getItem(0);
        if (input.isEmpty()) {
            return false;
        }
        return !resolveResult(input.getItem(), level, this).isEmpty();
    }

    @Override
    public ItemStack assemble(Container container, RegistryAccess registryAccess) {
        ItemStack input = container.getItem(0);
        if (input.isEmpty()) {
            return ItemStack.EMPTY;
        }
        ItemStack output = cachedResults.get(input.getItem());
        return output == null ? ItemStack.EMPTY : output.copy();
    }

    @Override
    public ItemStack getResultItem(RegistryAccess registryAccess) {
        return ItemStack.EMPTY;
    }

    @Override
    public RecipeSerializer<?> getSerializer() {
        return Blocksmelt.AUTOGENERATED_ORE_BLASTING_SERIALIZER.get();
    }

    @Override
    public boolean isSpecial() {
        return true;
    }

    private ItemStack resolveResult(Item inputItem, Level level, AutogeneratedOreBlastingRecipe recipe) {
        if (this.cachedRecipeManager != level.getRecipeManager()) {
            this.cachedRecipeManager = level.getRecipeManager();
            this.cachedResults.clear();
        }
        return this.cachedResults.computeIfAbsent(inputItem, item -> findBlastingResult(item, level, recipe));
    }

    private static ItemStack findBlastingResult(Item inputItem, Level level, AutogeneratedOreBlastingRecipe self) {
        if (!(inputItem instanceof BlockItem blockItem)) {
            return ItemStack.EMPTY;
        }
        if (!(blockItem.getBlock() instanceof ModifiedOreBlock oreBlock)) {
            return ItemStack.EMPTY;
        }

        ResourceLocation sourceOreId = findSourceOreId(oreBlock);
        if (sourceOreId == null) {
            return ItemStack.EMPTY;
        }

        Block sourceOreBlock = ForgeRegistries.BLOCKS.getValue(sourceOreId);
        if (sourceOreBlock == null || sourceOreBlock.asItem() == Items.AIR || sourceOreBlock instanceof ModifiedOreBlock) {
            return ItemStack.EMPTY;
        }

        Container sourceContainer = new SimpleContainer(new ItemStack(sourceOreBlock.asItem()));
        for (BlastingRecipe blastingRecipe : level.getRecipeManager().getAllRecipesFor(RecipeType.BLASTING)) {
            if (blastingRecipe == self) {
                continue;
            }
            if (!blastingRecipe.matches(sourceContainer, level)) {
                continue;
            }
            ItemStack result = blastingRecipe.getResultItem(level.registryAccess());
            if (!result.isEmpty()) {
                return result.copy();
            }
        }

        for (SmeltingRecipe smeltingRecipe : level.getRecipeManager().getAllRecipesFor(RecipeType.SMELTING)) {
            if (!smeltingRecipe.matches(sourceContainer, level)) {
                continue;
            }
            ItemStack result = smeltingRecipe.getResultItem(level.registryAccess());
            if (!result.isEmpty()) {
                return result.copy();
            }
        }

        return ItemStack.EMPTY;
    }

    private static @Nullable ResourceLocation findSourceOreId(ModifiedOreBlock oreBlock) {
        List<ResourceLocation> baseOreIds = oreBlock.ore.blockId;
        if (baseOreIds == null || baseOreIds.isEmpty()) {
            return null;
        }

        List<String> stoneIds = oreBlock.ore.stone;
        if (stoneIds != null && oreBlock.stone != null) {
            int stoneIndex = stoneIds.indexOf(oreBlock.stone.id);
            if (stoneIndex >= 0 && stoneIndex < baseOreIds.size()) {
                return baseOreIds.get(stoneIndex);
            }
        }

        return baseOreIds.get(0);
    }

    public static class Serializer implements RecipeSerializer<AutogeneratedOreBlastingRecipe> {
        @Override
        public AutogeneratedOreBlastingRecipe fromJson(ResourceLocation recipeId, JsonObject json) {
            return new AutogeneratedOreBlastingRecipe(recipeId);
        }

        @Override
        public @Nullable AutogeneratedOreBlastingRecipe fromNetwork(ResourceLocation recipeId, FriendlyByteBuf buffer) {
            return new AutogeneratedOreBlastingRecipe(recipeId);
        }

        @Override
        public void toNetwork(FriendlyByteBuf buffer, AutogeneratedOreBlastingRecipe recipe) {}
    }
}
